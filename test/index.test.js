import test from "jest-t-assert";
import xxhash from "../src";
import xxh3 from "../src/xxh3";
import xxh3p from "../src/xxh3-perf";
import fs from "fs";
import path from "path";

const fixtureText = fs.readFileSync(path.join(__dirname, 'fixture.txt')).toString();
const smallFixtureText = fs.readFileSync(path.join(__dirname, 'small-fixture.txt')).toString();
const mediumFixtureText = fs.readFileSync(path.join(__dirname, 'medium-fixture.txt')).toString();

// The test cases were taken from tests of other implementation and the
// resulting hashes have been generated by running another implementation.
// All cases used the seed 0.
const testCases = [
  { input: "", h32: "02cc5d05", h64: "ef46db3751d8e999", h3: "2d06800538d394c2" },
  { input: "a", h32: "550d7456", h64: "d24ec4f1a98c6e5b", h3: "e6c632b61e964e1f" },
  { input: "as", h32: "9d5a0464", h64: "1c330fb2d66be179", h3: "1e0844fa8dccd17d" },
  { input: "asd", h32: "3d83552b", h64: "631c37ce72a97393", h3: "ab4e634a5d854219" },
  { input: "asdf", h32: "5e702c32", h64: "415872f599cea71e", h3: "43a74511c2a27ecc" },
  { input: "abc", h32: "32d153ff", h64: "44bc2cf5ad770999", h3: "78af5f94892f3950" },
  { input: "abcd", h32: "a3643705", h64: "de0327b0d25d92cc", h3: "6497a96f53a89890" },
  { input: "3.14159", h32: "f7876132", h64: "fd47eac9931e5611", h3: "be806d59f2d89101" },
  { input: "hello world", h32: "cebb6622", h64: "45ab6734b21e6968", h3: "d447b1ea40e6988b" },
  { input: "0.7278296545100061", h32: "432c173f", h64: "596877150e8ee48c", h3: "76fa3a83a3d7d2f0" },
  {
    input: "Call me Ishmael. Some years ago--never mind how long precisely-",
    h32: "6f320359",
    h64: "02a2e85470d6fd96",
    h3: "3f1a447475ae2069",
  },
  {
    input:
      "The quick brown fox jumps over the lazy dog http://i.imgur.com/VHQXScB.gif",
    h32: "5ce7b616",
    h64: "93267f9820452ead",
    h3: "7dd84b026fe49d02",
  },
  {
    input:
      "The quick brown fox jumps over the lazy dog http://i.imgur.com/VHQXScB.gifThe quick brown fox jumps over the lazy dog http://i.imgur.com/VHQXScB.gif",
    h32: "9dac9bfd",
    h64: "0b009e8af3c3ca9e",
    h3: "131ee3a3a495f2db",
  },
  {
    input: "The quick brown fox jumps over the lazy dog http://i.imgur.com/VHQXScB.gifThe quick brown fox jumps over the lazy dog http://i.imgur.com/VHQXScB.gifThe quick brown fox jumps over the lazy dog http://i.imgur.com/VHQXScB.gifThe quick brown fox jumps over the lazy dog http://i.imgur.com/VHQXScB.gif",
    h32: "1d572f53",
    h64: "e9307287ad4300f3",
    h3: "3192ba1359e974b6",
  },
  { input: "heiå", h32: "db5abccc", h64: "b9d3d990d2001a1a" },
  { input: "κόσμε", h32: "d855f606", h64: "a0488960c70d8772" },
  { input: fixtureText, h32: "f758e234", h64: "b4f85e7e4844d8c2", h3: "93df499c3cb47148" },
  { input: smallFixtureText, h32: "dc7d964e", h64: "29eea1ad1ba99d57", h3: "b9642f814f7206e4"},
  { input: mediumFixtureText, h32: "0f06bc99", h64: "a14f7aeb87faaf4b", h3: "dd91cd2b84a5e23c"},
];

for (const testCase of testCases) {
  const testCaseIdentifier = testCase.input.length < 100 ? `"${testCase.input}"` : `${testCase.input.length}b`;

  test(`h32 of ${testCaseIdentifier}`, async (t) => {
    const hasher = await xxhash();
    const h32 = hasher.h32(testCase.input).toString(16).padStart(8, "0");
    t.is(h32, testCase.h32);
  });

  test(`h32ToString of ${testCaseIdentifier}`, async (t) => {
    const hasher = await xxhash();
    const h32 = hasher.h32ToString(testCase.input);
    t.is(h32, testCase.h32);
  });

  test(`h32Raw of ${testCaseIdentifier}`, async (t) => {
    const encoder = new TextEncoder();
    const hasher = await xxhash();
    const h32 = hasher
      .h32Raw(encoder.encode(testCase.input))
      .toString(16)
      .padStart(8, "0");
    t.is(h32, testCase.h32);
  });

  test(`streamed h32 of ${testCaseIdentifier}`, async (t) => {
    const hasher = await xxhash();
    const h32 = hasher
      .create32()
      .update(testCase.input)
      .digest()
      .toString(16)
      .padStart(8, "0");
    t.is(h32, testCase.h32);
  });

  test(`h64 of ${testCaseIdentifier}`, async (t) => {
    const hasher = await xxhash();
    const h64 = hasher.h64(testCase.input);
    t.is(h64, BigInt(`0x${testCase.h64}`));
  });

  test(`h64ToString of ${testCaseIdentifier}`, async (t) => {
    const hasher = await xxhash();
    const h64 = hasher.h64ToString(testCase.input);
    t.is(h64, testCase.h64);
  });

  test(`h64Raw of ${testCaseIdentifier}`, async (t) => {
    const encoder = new TextEncoder();
    const hasher = await xxhash();
    const h64 = hasher.h64Raw(encoder.encode(testCase.input));
    t.is(h64, BigInt(`0x${testCase.h64}`));
  });

  test(`streamed h64 of ${testCaseIdentifier}`, async (t) => {
    const hasher = await xxhash();
    const h64 = hasher
      .create64()
      .update(testCase.input)
      .digest()
      .toString(16)
      .padStart(16, "0");
    t.is(h64, testCase.h64);
  });

  if ('h3' in testCase) {
    test(`h3ToString of ${testCaseIdentifier}`, async (t) => {
      const hasher = await xxh3();
      const hasherp = await xxh3p();
      t.is(hasher.h3ToString(testCase.input), testCase.h3);
      t.is(hasherp.h3ToString(testCase.input), testCase.h3);
    });
  }
}
/*
test("h32 with different seeds produces different hashes", async (t) => {
  const hasher = await xxhash();
  const input = "different seeds";
  const h320 = hasher.h32(input, 0);
  const h32abcd = hasher.h32(input, 0xabcd);
  t.not(h320, h32abcd);
});

test("h64 with different seeds produces different hashes", async (t) => {
  const hasher = await xxhash();
  const input = "different seeds";
  const h640 = hasher.h64(input, 0n);
  const h64lowAbcd = hasher.h64(input, BigInt(0xabcd));
  const h64highAbcd = hasher.h64(input, BigInt(0xabcd) << (32n + BigInt(0)));
  t.not(h640, h64lowAbcd);
  t.not(h640, h64highAbcd);
  t.not(h64lowAbcd, h64highAbcd);
});

test("a string greater than the initial memory size works", async (t) => {
  const hasher = await xxhash();
  const bytesPerPage = 64 * 1024;
  const input = "z".repeat(bytesPerPage + 1);
  const h32 = hasher.h32ToString(input, 0);
  const h64 = hasher.h64ToString(input, 0n);
  t.is(h32, "7871ee9b");
  t.is(h64, "68278ba56dc14510");
});

test("streamed h32 with multiple inputs produces same hash", async (t) => {
  const hasher = await xxhash();
  const { update, digest } = hasher.create32(0);
  update("hello");
  update("world");
  t.is(digest(), hasher.h32("helloworld"));
});

test("streamed h64 with multiple inputs produces same hash", async (t) => {
  const hasher = await xxhash();
  const { update, digest } = hasher.create64(0n);
  update("hello");
  update("world");
  t.is(digest(), hasher.h64("helloworld"));
});

test("streamed h32 with buffer input produces same hash", async (t) => {
  const input = Buffer.from("helloworld");
  const hasher = await xxhash();
  t.is(hasher.create32(0).update(input).digest(), hasher.h32Raw(input));
});

test("streamed h64 with buffer input produces same hash", async (t) => {
  const input = Buffer.from("helloworld");
  const hasher = await xxhash();
  t.is(hasher.create64(0n).update(input).digest(), hasher.h64Raw(input));
});*/
